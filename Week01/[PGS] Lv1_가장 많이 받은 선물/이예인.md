# [난이도] 문제명

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/258712)


`#구현`

### 성능 요약

메모리:  KB, 시간:  ms <br>
시간복잡도: O(n^2)

### 제출 일자

2026년 2월 12일 

### 문제 설명
다음 달에 누가 얼마나 선물을 받을지를 아래 규칙으로 계산하고, <br>
그중 가장 많이 받은 친구가 받을 선물 수를 구해야 한다. <br>
선물을 받는 규칙 <br>
각 서로 다른 친구 A, B 쌍에 대해 비교합니다. <br>
1. 둘이 선물을 주고 받은 기록이 있다면, A->B, B->A 개수를 비교해서 많이 준 사람이 다음 달에 선물을 하나 받는다.
2. 주고 받은 기록이 없거나 개수가 같다면, 선물 지수를 비교한다.
3. 선물 지수 = 준 선물 개수 - 받은 선물 개수
4. 선물 지수가 큰 친구가 작은 친구에게 선물을 하나 받는다.
5. 선물 지수도 같다면 두 사람 간에 다음 달 선물은 없다.
6. 모든 쌍을 비교 한 후, 가장 많이 받은 친구의 선물 수를 리턴한다. 

### 입력
- `friends` : 친구 이름들의 배열
- `gifts` : "A B"처럼 준 사람과 받은 사람 기록 리스트

### 출력
- 다음 달 가장 많은 선물을 받는 친구가 받는 선물 수(정수)
<hr>

### 핵심 풀이 전략
1. 친구 이름을 인덱스로 다루기 위해 `friends`의 각 이름을 0~n-1로 대응시킨다.

2. 이번 달 선물 기록을 기반으로
- `givetake[a][b]` = a가 b에게 준 선물 횟수(2차원 배열)
- `gift_value[i]` = i의 선물 지수 = (준 횟수) - (받은 횟수) 를 계산한다.

3. 다음 달 선물은 모든 친구 쌍(i, j)에 대해 규칙대로 결정한다.
- `givetake[i][j] > givetake[j][i]` 이면 i가 다음 달 선물 1개 받음
- 주고받은 횟수가 같으면 `gift_value[i] > gift_value[j]` 인 경우 i가 1개 받음
- 그 외는 없음 <br>
이를 `gift[i]`에 누적한다.

4. 마지막으로 `gift[]` 중 최댓값이 다음 달 가장 많이 받는 선물 수이므로 이를 반환한다.


```java
class Solution {
    public int solution(String[] friends, String[] gifts) {
        
        int friends_num = friends.length;
        int[][] givetake = new int[friends_num][friends_num];
        int[] gift_value = new int[friends_num];
        int[] gift = new int[friends_num];
        
        for(int i = 0; i < gifts.length; i++){
            
            String[] gift_friend = gifts[i].split(" ");
            String give_friend = gift_friend[0];
            String take_friend = gift_friend[1];
            
            int give_num = -1;
            int take_num = -1;
            
            for(int j = 0; j < friends_num; j++){
                if(give_friend.equals(friends[j])){
                    give_num = j;
                    gift_value[j]++;
                }
                if(take_friend.equals(friends[j])){
                    take_num = j;
                    gift_value[j]--;
                }
            }
            givetake[give_num][take_num]++;
           
        }
        
        for(int i = 0; i < friends_num; i++){
            for(int j = 0; j < friends_num; j++){
                if(i==j) continue;
                if(givetake[i][j] > givetake[j][i]) gift[i]++;
                else if (givetake[i][j] == givetake[j][i] && gift_value[i] > gift_value[j]) gift[i]++;
            }
        }
        
        int max = -1;
        for(int i = 0 ; i < friends_num; i++){
                if(gift[i] > max) max = gift[i];
        }
        return max;

    }
}

```


---

### 삽길 기록 🧠


---

### 배운 점 && 보완할 점
