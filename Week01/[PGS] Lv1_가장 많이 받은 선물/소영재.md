# [Lv1] 가장 많이 받은 선물

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/258712)

`#구현`

### 제출 일자

2026년 2월 19일

### 문제 설명 (요약)
이번 달까지 선물을 주고 받은 기록을 바탕으로 다음 달에 선물을 가장 많이 받게 될 친구의 선물 개수 예측
1. 두 사람이 선물을 주고받은 기록이 있다면, 이번 달까지 두 사람 사이에 더 많은 선물을 준 사람이 다음 달에 선물을 하나 받는다.
2. 선물 지수는 이번 달까지 준 선물의 수에서 받은 선물의 수를 뺀 값이다.
3. 두 사람이 선물을 주고받은 기록이 하나도 없거나 주고 받은 수가 같다면, 선물 지수가 더 큰 사람이 선물 지수가 더 작은 사람에게 선물을 받는다.
4. 만약 두 사람의 선물 지수가 같다면, 다음 달에 선물을 주고 받지 않는다.

### 입력
String[] friends : 친구들의 이름이 담긴 배열
String[] gifts : 선물을 주고 받은 기록이 담긴 배열 (공백으로 구분)

### 출력
다음 달에 가장 많이 선물을 받는 친구의 선물 수 
<hr>

### 핵심 풀이 전략
gifts 배열에 공백으로 사람을 구분한 점을 이용
문자열 상태로는 계산을 할 수 없기 때문에 2차원 배열을 활용한 매핑
정보를 기록할 때 모든 상태를 동시에 업데이트
---

```java
class Solution {
    public int solution(String[] friends, String[] gifts) {
        
        //반복문에서 friends 배열 크기를 활용하기 위해 변수 선언
        int friendCount = friends.length;
        
        //선물을 준 횟수를 담는 2차원 배열 변수 선언
        int[][] giftArrays = new int[friendCount][friendCount];
        
        //선물 지수를 담는 배열 변수 선언
        int[] presentIndex = new int[friendCount];
        
        for (int i = 0; i < gifts.length; i++){
            String[] ex = gifts[i].split(" ");
            String fromName = ex[0]; //선물을 준 사람
            String toName = ex[1]; //선물을 받은 사람
            
            int from = 0;
            int to = 0;
            
            for(int j = 0; j < friends.length; j++){
                if(friends[j].equals(fromName)){
                 from = j;
                 }
                if(friends[j].equals(toName)){
                 to = j;
                 }
            }
            giftArrays[from][to]++;
            presentIndex[from]++; 
            presentIndex[to]--;
        }
        
        //다음 달에 받을 선물 개수
        int[] nextMonth = new int[friendCount];
        
        for(int i = 0; i < friendCount; i++){
            for(int j = i + 1; j < friendCount; j++){
                if(giftArrays[i][j] > giftArrays[j][i]){
                    nextMonth[i]++;
                } else if (giftArrays[i][j] < giftArrays[j][i]){
                    nextMonth[j]++;
                } else {
                    if(presentIndex[i] > presentIndex[j]){
                        nextMonth[i]++;
                    } else if (presentIndex[i] < presentIndex[j]){
                        nextMonth[j]++;
                    }
                }
            }
        }
        
        int max = 0;
        for (int i = 0; i < friendCount; i++){
            if(nextMonth[i] > max){
            max = nextMonth[i];
            }
        }
        return max;
    }
}

### 삽질 기록 🧠

---

### 배운 점 && 보완할 점

